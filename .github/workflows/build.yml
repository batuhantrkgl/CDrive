name: Build and Release

on:
  push:
    branches: [ main, develop, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Platforms to build (comma-separated: linux-x86_64,linux-i386,linux-arm64,linux-armhf,darwin-x86_64,darwin-arm64,windows-x86_64,windows-i386 or "all")'
        required: false
        default: 'all'
        type: string
      debug:
        description: 'Enable debug build'
        required: false
        default: false
        type: boolean
      create_release:
        description: 'Create a new release (only on main/master branch)'
        required: false
        default: false
        type: boolean
      version:
        description: 'Release version (auto-generated if empty)'
        required: false
        default: ''
        type: string

jobs:
  build:
    name: Build on ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    
    strategy:
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            platform: linux-x86_64
            arch: x86_64
            deps_install: |
              sudo apt-get update
              sudo apt-get install -y build-essential libcurl4-openssl-dev libjson-c-dev
          - os: ubuntu-latest
            platform: linux-i386
            arch: i386
            deps_install: |
              sudo apt-get update
              sudo apt-get install -y build-essential gcc-multilib libc6-dev-i386
              sudo dpkg --add-architecture i386
              sudo apt-get update
              sudo apt-get install -y libcurl4-openssl-dev:i386 libjson-c-dev:i386
          - os: ubuntu-latest
            platform: linux-arm64
            arch: arm64
            deps_install: |
              sudo apt-get update
              sudo apt-get install -y build-essential gcc-aarch64-linux-gnu
              sudo dpkg --add-architecture arm64 || true
              sudo sed -i 's/deb http/deb [arch=amd64] http/g' /etc/apt/sources.list
              echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble main universe" | sudo tee -a /etc/apt/sources.list
              echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-updates main universe" | sudo tee -a /etc/apt/sources.list
              sudo apt-get update || true
              sudo apt-get install -y libcurl4-openssl-dev:arm64 libjson-c-dev:arm64 || sudo apt-get install -y libcurl4-openssl-dev libjson-c-dev
          - os: ubuntu-latest
            platform: linux-armhf
            arch: armhf
            deps_install: |
              sudo apt-get update
              sudo apt-get install -y build-essential gcc-arm-linux-gnueabihf
              sudo dpkg --add-architecture armhf || true
              sudo sed -i 's/deb http/deb [arch=amd64] http/g' /etc/apt/sources.list
              echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports noble main universe" | sudo tee -a /etc/apt/sources.list
              echo "deb [arch=armhf] http://ports.ubuntu.com/ubuntu-ports noble-updates main universe" | sudo tee -a /etc/apt/sources.list
              sudo apt-get update || true
              sudo apt-get install -y libcurl4-openssl-dev:armhf libjson-c-dev:armhf || sudo apt-get install -y libcurl4-openssl-dev libjson-c-dev
          # macOS builds
          - os: macos-13
            platform: darwin-x86_64
            arch: x86_64
            deps_install: |
              brew install curl json-c pkg-config
          - os: macos-latest
            platform: darwin-arm64
            arch: arm64
            deps_install: |
              brew install curl json-c pkg-config
          # Windows builds
          - os: windows-latest
            platform: windows-x86_64
            arch: x86_64
            deps_install: |
              # MSYS2 will be set up separately
          - os: windows-latest
            platform: windows-i386
            arch: i386
            deps_install: |
              # MSYS2 will be set up separately
    
    steps:
    - name: Check if platform should be built
      id: should_build
      shell: bash
      run: |
        if [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
          echo "should_build=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event.inputs.platforms }}" == "all" ]]; then
          echo "should_build=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event.inputs.platforms }}" == *"${{ matrix.platform }}"* ]]; then
          echo "should_build=true" >> $GITHUB_OUTPUT
        else
          echo "should_build=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Checkout code
      if: steps.should_build.outputs.should_build == 'true'
      uses: actions/checkout@v4
      
    - name: Setup MSYS2 (Windows only)
      if: startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'
      uses: msys2/setup-msys2@v2
      with:
        msystem: ${{ matrix.arch == 'i386' && 'MINGW32' || 'MINGW64' }}
        install: >-
          ${{ matrix.arch == 'i386' && 'mingw-w64-i686-gcc mingw-w64-i686-make mingw-w64-i686-curl mingw-w64-i686-json-c make' || 'mingw-w64-x86_64-gcc mingw-w64-x86_64-make mingw-w64-x86_64-curl mingw-w64-x86_64-json-c make' }}
      
    - name: Install dependencies (Linux/macOS)
      if: "!startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'"
      run: ${{ matrix.deps_install }}
      
    - name: Build (Linux x86_64)
      if: matrix.platform == 'linux-x86_64' && steps.should_build.outputs.should_build == 'true'
      run: |
        make clean
        ${{ github.event.inputs.debug == 'true' && 'make debug' || 'make' }}
        
    - name: Build (Linux i386)
      if: matrix.platform == 'linux-i386' && steps.should_build.outputs.should_build == 'true'
      run: |
        make clean
        export PKG_CONFIG_PATH="/usr/lib/i386-linux-gnu/pkgconfig:$PKG_CONFIG_PATH"
        export PKG_CONFIG_LIBDIR="/usr/lib/i386-linux-gnu/pkgconfig"
        CFLAGS="-m32 $(pkg-config --cflags libcurl json-c)"
        LIBS="$(pkg-config --libs libcurl json-c)"
        ${{ github.event.inputs.debug == 'true' && 'make debug CC="gcc -m32" CFLAGS="$CFLAGS -g -DDEBUG" LIBS="$LIBS"' || 'make CC="gcc -m32" CFLAGS="$CFLAGS" LIBS="$LIBS"' }}
        
    - name: Build (Linux ARM64)
      if: matrix.platform == 'linux-arm64' && steps.should_build.outputs.should_build == 'true'
      run: |
        make clean
        export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:$PKG_CONFIG_PATH"
        export PKG_CONFIG_LIBDIR="/usr/lib/aarch64-linux-gnu/pkgconfig"
        CFLAGS="$(pkg-config --cflags libcurl json-c)"
        LIBS="$(pkg-config --libs libcurl json-c)"
        ${{ github.event.inputs.debug == 'true' && 'make debug CC=aarch64-linux-gnu-gcc CFLAGS="$CFLAGS -g -DDEBUG" LIBS="$LIBS"' || 'make CC=aarch64-linux-gnu-gcc CFLAGS="$CFLAGS" LIBS="$LIBS"' }}
        
    - name: Build (Linux ARMHF)
      if: matrix.platform == 'linux-armhf' && steps.should_build.outputs.should_build == 'true'
      run: |
        make clean
        export PKG_CONFIG_PATH="/usr/lib/arm-linux-gnueabihf/pkgconfig:$PKG_CONFIG_PATH"
        export PKG_CONFIG_LIBDIR="/usr/lib/arm-linux-gnueabihf/pkgconfig"
        CFLAGS="$(pkg-config --cflags libcurl json-c)"
        LIBS="$(pkg-config --libs libcurl json-c)"
        ${{ github.event.inputs.debug == 'true' && 'make debug CC=arm-linux-gnueabihf-gcc CFLAGS="$CFLAGS -g -DDEBUG" LIBS="$LIBS"' || 'make CC=arm-linux-gnueabihf-gcc CFLAGS="$CFLAGS" LIBS="$LIBS"' }}
        
    - name: Build (macOS x86_64)
      if: matrix.platform == 'darwin-x86_64' && steps.should_build.outputs.should_build == 'true'
      run: |
        make clean
        export PKG_CONFIG_PATH="$(brew --prefix)/lib/pkgconfig:$PKG_CONFIG_PATH"
        CFLAGS="-arch x86_64 $(pkg-config --cflags libcurl json-c)"
        LIBS="$(pkg-config --libs libcurl json-c)"
        ${{ github.event.inputs.debug == 'true' && 'make debug CFLAGS="$CFLAGS -g -DDEBUG" LIBS="$LIBS"' || 'make CFLAGS="$CFLAGS" LIBS="$LIBS"' }}
        
    - name: Build (macOS ARM64)
      if: matrix.platform == 'darwin-arm64' && steps.should_build.outputs.should_build == 'true'
      run: |
        make clean
        export PKG_CONFIG_PATH="$(brew --prefix)/lib/pkgconfig:$PKG_CONFIG_PATH"
        CFLAGS="-arch arm64 $(pkg-config --cflags libcurl json-c)"
        LIBS="$(pkg-config --libs libcurl json-c)"
        ${{ github.event.inputs.debug == 'true' && 'make debug CFLAGS="$CFLAGS -g -DDEBUG" LIBS="$LIBS"' || 'make CFLAGS="$CFLAGS" LIBS="$LIBS"' }}
        
    - name: Build (Windows)
      if: startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'
      shell: msys2 {0}
      run: |
        make clean
        ${{ github.event.inputs.debug == 'true' && 'make debug LIBS="-lcurl -ljson-c -lws2_32"' || 'make LIBS="-lcurl -ljson-c -lws2_32"' }}
        
    - name: Test basic functionality (Linux/macOS)
      if: "!startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'"
      run: |
        if [ -f out/dist/cdrive ]; then
          ./out/dist/cdrive --help || echo "Help command executed"
          ./out/dist/cdrive --version || echo "Version command executed"
        elif [ -f out/dist/cdrive-debug ]; then
          ./out/dist/cdrive-debug --help || echo "Help command executed"
          ./out/dist/cdrive-debug --version || echo "Version command executed"
        else
          echo "Binary not found in expected location"
          ls -la out/dist/
        fi
        
    - name: Test basic functionality (Windows)
      if: startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'
      shell: msys2 {0}
      run: |
        if [ -f out/dist/cdrive.exe ]; then
          ./out/dist/cdrive.exe --help || echo "Help command executed"
          ./out/dist/cdrive.exe --version || echo "Version command executed"
        elif [ -f out/dist/cdrive-debug.exe ]; then
          ./out/dist/cdrive-debug.exe --help || echo "Help command executed"
          ./out/dist/cdrive-debug.exe --version || echo "Version command executed"
        else
          echo "Binary not found in expected location"
          ls -la out/dist/
        fi
        
    - name: Create archive (Linux/macOS)
      if: "!startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'"
      run: |
        mkdir -p dist
        cp out/dist/cdrive dist/ || cp out/dist/cdrive-debug dist/
        archive_name="cdrive-${{ matrix.platform }}${{ github.event.inputs.debug == 'true' && '-debug' || '' }}.tar.gz"
        cd dist && tar -czf ../$archive_name cdrive*
        
    - name: Create archive (Windows)
      if: startsWith(matrix.platform, 'windows') && steps.should_build.outputs.should_build == 'true'
      shell: bash
      run: |
        mkdir -p dist
        cp out/dist/cdrive.exe dist/ || cp out/dist/cdrive-debug.exe dist/ || cp out/dist/cdrive dist/cdrive.exe
        archive_name="cdrive-${{ matrix.platform }}${{ github.event.inputs.debug == 'true' && '-debug' || '' }}.tar.gz"
        cd dist && tar -czf ../$archive_name cdrive*
        
    - name: Upload artifacts
      if: steps.should_build.outputs.should_build == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: cdrive-${{ matrix.platform }}${{ github.event.inputs.debug == 'true' && '-debug' || '' }}
        path: cdrive-*.tar.gz
        retention-days: 30

  create-combined-artifact:
    name: Combine All Builds
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts
        
    - name: Combine artifacts
      run: |
        mkdir -p ./combined
        find ./artifacts -name "*.tar.gz" -exec cp {} ./combined/ \;
        ls -la ./combined/
        
    - name: Upload combined artifacts
      uses: actions/upload-artifact@v4
      with:
        name: cdrive-all-platforms${{ github.event.inputs.debug == 'true' && '-debug' || '' }}
        path: ./combined/*.tar.gz
        retention-days: 90

  create-release:
    name: Create Release
    needs: [build, create-combined-artifact]
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true')
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_url: ${{ steps.release.outputs.html_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract version from cdrive.h
      id: version
      run: |
        if [[ "${{ github.event.inputs.version }}" != "" ]]; then
          VERSION="${{ github.event.inputs.version }}"
          echo "Using manual version: ${VERSION}"
        else
          # Extract version from cdrive.h (look for CDRIVE_VERSION define)
          VERSION_LINE=$(grep 'CDRIVE_VERSION' cdrive.h | head -1)
          if [[ -n "$VERSION_LINE" ]]; then
            # Extract version between quotes using cut
            VERSION=$(echo "$VERSION_LINE" | cut -d'"' -f2)
            echo "Extracted version from cdrive.h: ${VERSION}"
          else
            echo "Could not extract version from cdrive.h, falling back to auto-generation"
            DATE=$(date +'%Y.%m.%d')
            COMMIT_COUNT=$(git rev-list --count HEAD)
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="${DATE}.${COMMIT_COUNT}-${SHORT_SHA}"
            echo "Generated fallback version: ${VERSION}"
          fi
        fi
        echo "version=${VERSION}" >> $GITHUB_OUTPUT

    - name: Update README.md with new version
      id: update_readme
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Extract just the version number for badges (remove date if present)
        # Extract pattern like "1.0.1" from "1.0.1 (2025-08-11)"
        BADGE_VERSION=$(echo "$VERSION" | grep -o '^[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "$VERSION")
        
        echo "Full version: $VERSION"
        echo "Badge version: $BADGE_VERSION"
        
        # Update version badge with the clean version number
        sed -i "s/version-[^-]*-green/version-${BADGE_VERSION}-green/g" README.md
        
        # Update any version references in the README
        sed -i "s/\[Version\](https:\/\/img\.shields\.io\/badge\/version-[^-]*-green\.svg)/[Version](https:\/\/img.shields.io\/badge\/version-${BADGE_VERSION}-green.svg)/g" README.md
        
        # Also update the release URL in any file that references it
        if grep -q "releases/tag/" main.c; then
          sed -i "s|releases/tag/[^\"]*|releases/tag/v${VERSION}|g" main.c
          echo "Updated release URL in main.c"
        fi
        
        # Update version in cdrive.h if it exists
        if grep -q "CDRIVE_VERSION" cdrive.h; then
          sed -i "s/CDRIVE_VERSION \"[^\"]*\"/CDRIVE_VERSION \"${BADGE_VERSION}\"/g" cdrive.h
          echo "Updated CDRIVE_VERSION in cdrive.h"
        fi
        
        # Check if changes were made
        if git diff --quiet README.md main.c cdrive.h; then
          echo "changes=false" >> $GITHUB_OUTPUT
          echo "No changes needed in README.md, main.c, or cdrive.h"
        else
          echo "changes=true" >> $GITHUB_OUTPUT
          echo "Updated files with version ${BADGE_VERSION}"
          echo "README.md changes:"
          git diff README.md | head -10 || true
          echo "main.c changes:"
          git diff main.c | head -10 || true
          echo "cdrive.h changes:"
          git diff cdrive.h | head -10 || true
        fi

    - name: Commit README changes
      if: steps.update_readme.outputs.changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add README.md main.c cdrive.h
        git commit -m "🚀 Release v${{ steps.version.outputs.version }}: Update version badges and URLs"
        git push

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./release-artifacts

    - name: Prepare release files
      run: |
        mkdir -p ./release
        find ./release-artifacts -name "*.tar.gz" -exec cp {} ./release/ \;
        ls -la ./release/
        
        # Create a comprehensive release archive
        cd release
        tar -czf "cdrive-v${{ steps.version.outputs.version }}-all-platforms.tar.gz" *.tar.gz
        
        # Generate checksums
        sha256sum *.tar.gz > checksums.txt
        
        ls -la

    - name: Generate Release Notes
      id: release_notes
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # Get recent commits for release notes
        COMMITS=$(git log --oneline --since="7 days ago" --pretty=format:"- %s (%h)" | head -10)
        
        cat > release_notes.md << EOF
        # CDrive v${VERSION}
        
        A cross-platform Google Drive CLI tool written in C.
        
        ## 📦 Downloads
        
        Choose the appropriate binary for your platform:
        
        ### Linux
        - **x86_64**: \`cdrive-linux-x86_64.tar.gz\` (Intel/AMD 64-bit)
        - **i386**: \`cdrive-linux-i386.tar.gz\` (Intel/AMD 32-bit)
        - **ARM64**: \`cdrive-linux-arm64.tar.gz\` (ARM 64-bit)
        - **ARMHF**: \`cdrive-linux-armhf.tar.gz\` (ARM 32-bit with hardware floating point)
        
        ### Windows
        - **x86_64**: \`cdrive-windows-x86_64.tar.gz\` (Intel/AMD 64-bit)
        - **i386**: \`cdrive-windows-i386.tar.gz\` (Intel/AMD 32-bit)
        
        ### macOS
        - **Intel**: \`cdrive-darwin-x86_64.tar.gz\` (Intel Macs)
        - **Apple Silicon**: \`cdrive-darwin-arm64.tar.gz\` (M1/M2/M3 Macs)
        
        ### All Platforms
        - **Complete Bundle**: \`cdrive-v${VERSION}-all-platforms.tar.gz\` (All platforms in one archive)
        
        ## 🔧 Installation
        
        1. Download the appropriate archive for your platform
        2. Extract: \`tar -xzf cdrive-<platform>.tar.gz\`
        3. Make executable: \`chmod +x cdrive\` (Linux/macOS)
        4. Move to PATH: \`sudo mv cdrive /usr/local/bin/\` (Linux/macOS)
        
        ## ✨ Features
        
        - 🔐 **OAuth2 Authentication** - Secure Google Drive authentication
        - 📤 **File Upload** - Upload files with real-time progress indication
        - 📁 **Folder Management** - Create and organize folders
        - 📋 **File Listing** - Browse Google Drive contents
        - 🎨 **Colored Output** - Beautiful terminal interface with colors
        - ⚡ **Fast & Lightweight** - Written in C for optimal performance
        - 🔄 **Token Management** - Automatic token refresh and secure storage
        - 🌍 **Cross-Platform** - Works on Linux, Windows, and macOS
        
        ## 📝 Recent Changes
        
        ${COMMITS}
        
        ## 🔒 Checksums
        
        Verify your download with SHA256:
        \`\`\`
        $(cat release/checksums.txt)
        \`\`\`
        
        ## 🚀 Quick Start
        
        1. Set up Google Drive API credentials
        2. Authenticate: \`cdrive auth login\`
        3. Upload a file: \`cdrive upload ./myfile.txt\`
        4. List files: \`cdrive list\`
        
        ## 📖 Documentation
        
        Full documentation available in the [README.md](https://github.com/${{ github.repository }}/blob/main/README.md)
        
        ---
        
        **Built with ❤️ in C** | **Release Date**: $(date +'%Y-%m-%d %H:%M:%S UTC')
        EOF
        
        echo "Release notes generated successfully"

    - name: Create Release
      id: release
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        TAG_NAME="v${VERSION}"
        RELEASE_NAME="CDrive v${VERSION}"
        
        echo "Creating release with tag: ${TAG_NAME}"
        echo "Release name: ${RELEASE_NAME}"
        
        # Create the release using GitHub CLI
        gh release create "${TAG_NAME}" \
          --title "${RELEASE_NAME}" \
          --notes-file release_notes.md \
          --target "${GITHUB_SHA}" \
          --repo "${{ github.repository }}"
        
        # Get the release URL for output
        RELEASE_URL=$(gh release view "${TAG_NAME}" --json url --jq '.url' --repo "${{ github.repository }}")
        echo "html_url=${RELEASE_URL}" >> $GITHUB_OUTPUT
        echo "upload_url=${RELEASE_URL}/assets" >> $GITHUB_OUTPUT
        
        echo "✅ Release created successfully: ${RELEASE_URL}"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload Release Assets
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        TAG_NAME="v${VERSION}"
        
        cd release
        
        echo "📦 Uploading release assets for ${TAG_NAME}..."
        
        # Upload individual platform archives
        for file in cdrive-*.tar.gz; do
          if [[ "$file" != *"all-platforms"* ]]; then
            echo "Uploading: $file"
            gh release upload "${TAG_NAME}" "$file" --repo "${{ github.repository }}"
          fi
        done
        
        # Upload the complete bundle
        echo "Uploading: cdrive-v${VERSION}-all-platforms.tar.gz"
        gh release upload "${TAG_NAME}" "cdrive-v${VERSION}-all-platforms.tar.gz" --repo "${{ github.repository }}"
        
        # Upload checksums
        echo "Uploading: checksums.txt"
        gh release upload "${TAG_NAME}" checksums.txt --repo "${{ github.repository }}"
        
        echo "✅ All release assets uploaded successfully!"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update Release Description
      run: |
        echo "🎉 Release v${{ steps.version.outputs.version }} created successfully!"
        echo "📍 Release URL: ${{ steps.release.outputs.html_url }}"
        echo "🏷️  Tag: v${{ steps.version.outputs.version }}"
        echo ""
        echo "The release includes:"
        echo "- Binaries for all supported platforms"
        echo "- Updated README.md with new version"
        echo "- SHA256 checksums for verification"
        echo "- Comprehensive release notes"
